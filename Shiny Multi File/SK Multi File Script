#Small Shiny app to predict ED demand using FB Prophet (https://facebook.github.io/prophet/)
#Requires data processed via NHS Demand and Capacity Team ED Model for correct formatting
#Outputs .CSV file with predicted attendances for the next week (by hour).

#To do:
#1. Improve UI of app
#2. Ensure optimisation of code - 06/08
#3. Allow user input of some key parameters via a helper header row
#4. Create 'loading...' notification - completed 01/08
#5. Multiple file upload and processing

#Required libraries:
library(shiny)
library(prophet)
library(anytime)
library(shinycssloaders)
library(ggplot2)
library(readr)

#Define UI for data upload

ui <- fluidPage(
  
  titlePanel(span(style = "color: rgb(0,94,184)","NHS Demand and Capacity Forecasting Tool"), windowTitle = "NHS Demand and Capacity Forecasting Tool"),
  
  sidebarLayout(
    
    #Sidebar panel for user interaction
    sidebarPanel(h3("Data Upload"),
                 
                 fileInput(inputId = 'file1', label = "Upload dataset here:",multiple = TRUE,
                           accept = c("text/csv",
                                      "text/comma-separated-values,text/plain",
                                      ".csv")),
                 
                 downloadButton("downloadData", "Download"),
                 br(),
                 br(),
                 em("Please do not click the download button until the graph on the right has been generated")
    ),
    
    
    # Main panel for displaying outputs ----
    mainPanel(
      img(src = 'NHS.png', align = "right", height="15%", width="15%"),
      
      withSpinner(textOutput("forecast"))
      
    )
    
  ))


#Define server logic to process uploaded file
server <- function(input, output) {
  
  #Process data through prophet
  df_out <- eventReactive(input$file1, {
    
    df <- read_csv(input$file1$datapath) %>% tail(8784)
    df$ds <- anytime(df$ds)
    
    # generate list of streams
    collist <- colnames(df)[2:ncol(df)]
    
    for (i in collist){
    m <- prophet(yearly.seasonality = TRUE, 
                 weekly.seasonality = TRUE,
                 daily.seasonality = TRUE,
                 country_holidays = 'England') %>% prophet(df)
    
    future <- make_future_dataframe(m, periods = 168, freq = 3600)
    fcst <- tail(predict(m, future),168)[c('ds','yhat','yhat_lower','yhat_upper')]
    outlist <- c('ds',paste(i,'yhat'), paste(i,'yhat_lower'),paste(i,'yhat_upper'))
    
    if(exists('df_output'))
    {df_output[outlist[2:4]] <- fcst[outlist[2:4]]}
    else
    {df_output <- fcst}
    
    return(df_output)
    
    }
  })
  
  output$forecast <- renderText({df_out()$ds})
  
  
  #Process outputs to help chart display
#  fcst_m <- reactive({
#    fcst_m <- max(fcst_short()$yhat_upper)
#    return(fcst_m)
#  })
  
  #Present outputs in line and area chart
#  output$forecast <- renderPlot({
#    
#    req(input$file1)
#    
#    ggplot(data = fcst_short(), aes(x=ds,y=yhat))+
#      geom_ribbon(aes(ymin = yhat_lower, ymax = yhat_upper), fill = "blue", alpha=0.3)+
#      geom_line()+
#      ggtitle(file_name())+
#      xlab("Date")+
#      ylab("Attendances")+
#      scale_x_datetime(date_breaks = "12 hours")+
#      theme(plot.title = element_text(size = 22), axis.text.x = element_text(angle = 45, hjust = 1))+
#      coord_cartesian(ylim = c(0,fcst_m()))
#    
#  })
  
  #Define download parameters for outputs
  output$downloadData <- downloadHandler(
    filename = function () {
      paste("Import",substr(input$file1$name,7,nchar(input$file1$name)-4), Sys.Date(), ".csv",sep = ",")
    },
    content = function(file) {
      write.csv(df_out(), file)
    }
  )
}
# Run the app ----
shinyApp(ui, server)
